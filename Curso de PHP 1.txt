CURSO DE PHP 1

01 - INTRODUÇÃO AO PHP 8
Será mostrado a forma correta de como aprender e usar o php.

02 - O QUE PHP E COMO FUNCIONA
É uma linguagem de programa para web. Destina-se a objetos dinamicos.
**Como funciona
Acontece um request (pedido) sobre o endereço pesquisado e uma response (resposta). Pode acontecer que somente ja php ou php misturado  com html.

03 - INSTALAÇÃO DO LARAGON
Permite transformar o pc em um servidor web.
- Ir ao google  e procurar por laragon
- ir downloads e baixar a vesão full
Durante a instalaçao desmarcar a opção de iniciar com o windows.

04 - INSTALAÇÃO DO VISUAL CODE E PLUGINS
Instalar o php intelephense =  plugin
material icon theme
Durante a instalação do visual code, algumas caixas de seleções podem ser marcadas.

05 - FLUXO DE FUNCIONAMENTO DO AMBIENTE DE DESENVOLVIMENTO
Ativar Laragon
StartAll = inicia o servidor apache e gestor de banco de dados mysql.
Dentro da pasta www será a pasta de criação para todos os projetos.
Criar um arquivo de texto e renomear para receber a extensão de php.
Após botão direito, abrir com, visual code.
Caso seja preciso criar um projeto fora do padrão, criar uma pasta e seguir como os mesmos passos como se fosse html, modificando tambem nno browser colocando uma barra e o nome da pasta.

06 - COMO CRIAR SCRIPT E COMO USAR O PHP
- iniciar os serviços do laragon
Caso tenhamos um arquivo .html o processador nao reconhece comandos de php.

07 - POR QUE INDEX.PHP E INDEX.HTML
Foi debatido numa convenção mundial, visto que é a primeira página que o servidor busca ao ser feito um request.
Seria recomendado não existir ambos os ficheiros juntos no projeto. O servidor busca pelo index.html ou index.php, poderia dar conflito ao ter ambos ficheiros.

08 - APRESENTAÇÃO DE CONTEÚDO EM PHP
<?php
echo "php "; // maneira de escrever textos em php
echo 'php ';
echo ("php");
geralmente fica dentro do body em html, mas não é uma regra.

09 - COMENTÁRIOS EM PHP
São blocos de textos que são ignorados pelo navegador.
echo "php "; // maneira de escrever textos em php
echo 'php '; /* comentários de blocos*/
echo 'exemplo de comentários'; # comentário de uma linha
//echo '<br>'; ignora a linha de comando
Os comentários em php são ignorados quando acontece a renderização da página.

10 - VARIÁVEIS
São caixas para guardar valores e informações. No php as variaves não são tipificadas.
São casesensitive. Algumas regras para criação de variaves:
sem hifen
sem espaço
sem parenteses
sem nenhum tipo de acento

**Camel case = $meuNome
**Snake case = $meu_Nome
**Studly case = $MeuNome

11 - TIPOS DE DADOS
// o php ja detecta o tipo
$inteiro=100; # inteiro
$float=10.5; # casas decimais
$bool = true ou false; # recebe verdadeiro ou falso
$string = 'Olá mundo' # recebe dados alpha ou cadeias
$array = [1,2,3] # agrupa dados em  linha 
$pessoa = new pessoa(); # variavel para objetos
$null = null; # variavel que reseta

12 - OPERADOR DE ATRIBUIÇÃO
São simbolos ou sinais que permitem executar várias operações.
$variavel = 100; # insere valor a variavel
$nome = 'Luciano'; # insere informação a variavel
$x = 4 + 2; # adição
$x = 4 - 2; # subtração
$x = 4 * 2; # multiplicação
$x = 4 / 2; # divisão
$x = 4 % 2; # módulos (restante ou divisão)
$x = 4 ** 2; # potenciação

// exemplo de módulo
$x = 100 % 3; # 33,3.......1 = resto
$x = 60 % 3; #20.........0
$x = 13 % 2; #6.5.........1

13 - OPERADORES DE ATRIBUIÇÃO COMBINADOS
$a=10;

$a += 20; # seria o valor dela + 20
$a -= 5; # seria o valor dela - 5
$a *= 2; # seria o valor dela * 2
$a / 2; # seria o valor dela / 2
/*o codigo diminui e ganha mais clareza*/

#INCREMENTO E DECREMENTO
$a++; # valor de a + 1 = recebe
++$a; # valor de a + 1, ja vale como soma no valor de a

# PRÉ OU PÓS INCREMENTO OU DECREMENTO
$a--; # valor recebe a equação
--$a; # valor ja vale como menos o valor em '--'

14 - EXERCÍCIOS COM OPERADORES
Foram exercicios e fixação de operações e adição de valor pós cálculo.

15 - OPERADORES DE COMPARAÇÃO E SPACESHIP
Permitem comparar valores e tipo. Resultado sempre será verdadeiro ou falso.
// == comparação
$a=(2 == 3); # false
$a=(100 == 100); # vedadeiro
$a = (50 == '50'); # verdadeiro, ocorre a conversão implicita para valor numérico
$a = (50 === '50'); # falso, com '====' faz 2 verificação se o valor é igual e o tipo e igual

$a=(2 != 3); # diferente = true
$a = (2 <> 4 ); # maneira alternativa de comparação true
$a = (50 != 50); # ocorre o false pq são iguais
$a = (50 != '50'); # false, ocorre a conversão implicita para valor numérico
$a = (50 !== '50'); # true, pela tabela verdade, dando um verdadeira e outro false, o valor e verdadeiro

//MAIORES OU MENORES
$a = (2 > 3); # false, 2 é maior que 3
$a = (2 < 3); # verdadeiro
$a = (50 >= 50); # verdadeiro
$a = (50 <=50); # verdadeiro
$a = (50 < 50); # false

// OPERADOR SPACESHIP
$x = 1 <=> 1; # 0 (1 == 1) ocorre a comparação dos tipos nas laterais, caso ocorra zero é considerado valor neutro
$x = 3 <=> 2; # 1 ( 3 > 2), a comparação ocorre sendo que 3 pode ser menor, igual  ou maior que 2, dando 1 caso valor da esquerda seja maior que o valor da direita
$x = 1 <=> 2; # -1 (1 < 2)

16 - OPERADORES LÓGICOS
# operadores lógicos são usados junto com  operadores de comparação. Permitindo analisar blocos de comandos e decisão.
 
$a=100;
$b=200;

$x = ($a < $b) && ($a < 1000); # AND -> true
$x = ($a > $b) || ($a > 1000); # OR -> false (uma ou outra)
$x = ($a < 150) && ($b > 300); # FALSE
$x = ($a == 100) && ($b < 500); # FALSE

# OPERADORES LÓGICOS
# and, or e xor

# OPERADOR BINÁRIOS BITWISE
# Analisam valores de numeros equivalente em binário

17 - INTRODUÇÃO A STRINGS E CONCATENAÇÃO, HEREDOC E NOWDOC
String é uma série de caracteres que podem ser guardadas numa variável. Definida como um conjunto de letras, espaços, símbolos e numeros.

$a = "esta é uma string"; # double quote
$b = ' esta é outra string'; # simple quote

echo $a;
echo '<br>';
echo $b;

// CONCATENÇÃO '.' e '.='
$a = 'joao' . '' .'Ribeiro'; # ponto liga diferentes strings
$b='Joao';
$b.=''.'Ribeiro'; # .= faz uma ligação com valor já existente
echo $b;
die(); // função de finalização de código

$nome='joao';
$apelido='Ribeiro';
$nome_completo=$nome .''.$apelido;
echo $nome_completo;
die();


//alocando as variaves entre aspas duplas, a concatenação de variavel dentro de strings são subistuidas por valores.


//HEREDOC (outras formas de delimitação)
$cliente='Joao';
$email='joao@hotmail.com';
$texto = <<<LABEL
Olá, sr. $cliente.
Serve a presente mensagem para informar que se encontra inscrito no próximo concurs. Enviamos o regulamento para seu e-mail: $email
LABEL;
echo $texto;
die();

// NOWDOC (outras formas de delimitação)
$cliente='Joao';
$email='joao@hotmail.com';
$texto = <<<'LABEL' /*desta forma as variaveis nao serão exibidas*/
Olá, sr. $cliente.
Serve a presente mensagem para informar que se encontra inscrito no próximo concurs. Enviamos o regulamento para seu e-mail: $email
LABEL;
echo $texto;
die();

18 - CARACTERES DE ESCAPE, TERMINAL E HTML ENTITIE
São usados para inserir caracteres especiais, não causando conflito com a linguagem.
echo '<p>este é m paragráfo de HTML</p>';
echo '<br>';
$frase_1 = 'I´m going to John´s Party';
$frase_2='I´m going to john party';

//$frase_3="I´m not sure john "The Great" will win this fight.";
# a \ é o símbolo para definir um caracter de escape. A barra é o escape
$frase_1 = 'I\'m going to John\'s Party';
$frase_3="I'm not sure john \"The Great\" will win this fight.";
echo $frase_1;
echo '<br>';
echo $frase_3;

**USANDO TERMINAL
Menu terminal, novo terminal
- digitar php -v
Para corrigir erros, botao direito em meu computador, propriedades, configurações avançadas do sistema,
guia avançado,variaveis de ambiente, clicar em path e novo, colar o caminho porem ao final acrescentar uma '\' e ok.

C:\laragon\bin\php\php-8.1.10-Win32-vs16-x64

# CARACTER DE ESCAPE UNICODE
# https://www.utf8-chartable.de/

echo "\u{A9}"; # copyright
echo "\u{BC}"; # 1/4
echo "\u{AE}"; # registered trademark

# com HTML entities
# https://de.w3.org/html5/html5-authir/charref
# modelos de simbols iguais o PHP
echo '<br>'; # quebra de linha
echo '&copy';
echo '&frac14';
echo '&reg';

19 - FUNÇÕES PARA OPERAR STRINGS
Função é um bloco de códigos com argumentos.
$frase="Esta frase tem 29 caracteres.";
$n='<br>';
//apresenta o primeiro caracter da frase
echo $frase[0]; # forma de array
echo $n;

// apresenta o sexto caracter da frase
echo $frase[5];

# podemos comparar strings da seguinte forma
$a='Joao';
$b='Carlos';

$c=($a == $b); # false
$d = ($a != $b); # true

$frase='Esta frase tem 29 caracteres';
# retorno o numero de caracteres da string
$numero_caracteres_total=strlen($frase);

# retorna as letras a partir da posição 0 e durante 4 caracteres
$primeira_palavra=substr($frase,0,4); # esta

# converte todas em maiusculas
$todas_maiusculas=strtoupper($frase);

# converte todas em minusculas
$todas_minusculas = strtolower($frase);

# substituir uma letra por outra
$nova_frase=str_replace('a','x',$frase); # frxse = resultado

# verifica qual é a posição de um caracter dentro da string
$posicao=strpos($frase,'a'); # posição 3

# No php foram introduzidas mais algumas funções para usar com strings
#str_contains()
$nome="Luciano Leal Rodrigues";
$x=str_contains($nome,'Leal'); # true

#str_starts_with()
$x=str_starts_with($nome,'Luciano'); # true
$x=str_starts_with($nome,'luciano'); # false

# str_ends_with()
$x=str_ends_with($nome,'igues'); # true
$x=str_ends_with($nome,' igues'); # false

20 - EXERCICIOS DE FIXAÇÃO
<?php
$nome="Luciano";
$apelido="Leal Rodrigues";
echo "<h1> Meu nome é: $nome $apelido</h1>";



?>
<?= "<br>Este simbolo substitui o echo

--------
<?php
$nome="Luciano";
$apelido="Leal Rodrigues";
echo "<h1> Meu nome é: $nome $apelido</h1>";
$total="$nome $apelido";

echo "<br>Tendo o numero de letras:" .strlen($total)." de caracteres.";


?>

<p><?="Correção". mb_strtoupper($total)?></p> // desta forma todas vao sair em maiusculas

*********** ATIVAR EXTENSÕES EM PHP
-parar laragon
-botão direito no laragon
-php.ini, sendo aberto o noteplus++
-ctrl + f e digitar mbstring, após clicar em find até chegar nos módulos
-remover  o ';' no inicio da linha e salvar
-para confirmar ligar novamente o laragon, no vs ir no menu terminal, e digitar php -m
-na lista de módulos procurar por mbstring

21 - ARRAYS NUMÉRICOS E ARRAYS ASSOCIATIVO
# ARRAYS é uma variavel com vários espaços com chaves que são chamados de indices.(key)
$valores=[1,2,3,4,5]; 
$nomes=['joao','luciano','Grêmio'];
echo $valores[2];
echo $nomes[1];

# Determinando valores direto nas chaves
$dados =[
    10=>1000, // na posição 10 recebe o valor 1000
    20=>2000,
    30=>3000
];

# Adicionando valores na ultima posiçao
$dados[]=4000; # na ultima posição do array recebe o valor
array_push($dados,5000); 

# ARRAYS ASSOCIATIVOS
$dados=[
    'a'=>20,
    'b'=>30
];

$dados=[
    'nome'=>'joao',
    'sobrenome'=>'silva',
    'email'=>'joao@hotmail.com'
]; // evitar repertir itens no array pois ocorre a sobreposição de elementos.

# se fosse mostrado ficaria:
$dados['nome'];


22 - ARRAYS MISTOS E MULTIDIMENSIONAIS
# ARRAYS também podem combinar indices numéricos e strings.
$dados=[
    0=>10,
    'nome'=>'Luciano',
    10=>'40 anos'
];

# Não é uma estrutura recomendada.

# ARRAYS MULTIDIMENSIONAIS (matrizes)
$dados=[
    [10,20,30],
    [100,200,300],
    [1000,2000,3000]
];

# mostramos:
$dados=[1][2]; # sera mostrado 300  // linha e coluna

23 - INSTRUÇÃO CONDICIONAL (IF,ELSE,ELSEIF e ELSE)
 São blocos de comandos que decidem as atividades ou execuções.
# if
$nome="joao";
if($nome =="joao"){ // verificando se é igual, será executado se for true
    echo "Foi identificado como João";

# if e else
$idade=18;
if($idade <=18 ){ // se for
    echo "Adolescente";
}else{ // então ou caso contrário
    echo "Adulto";
}

# if, elseif e else

$nota=1;
if($nota <= 2){
    echo "Nota Fraca";
} elseif($nota <=4){
echo "Recuperação";
}elseif($nota <=8){
    echo "Nota muito boa";
}else{
    echo "Nota excelente";
}

# operadores lógicos

$num=20;
if($num > 10 && $num !=30){ // maior e diferente
    echo "Verdadeiro";
}else{
    echo "Falso";
}

# Condições dentro de condições (aninhamento)

$numero=10;

if($numero > 0){ // para executar o próximo bloco, esta condição deve ser realizada, caso contrário pula direto para o ultimo else e encerra o bloco de comandos.
    if($numero >=100){
        echo "O número é igual ou maior que 100";
    }else{
        echo "O número é positivo, mas inferior a 100";
    }
}else{
    echo "O número é negativo.";
}

24 - INSTRUÇÃO CONDICIONAL SWITCH e SINTAXE ALTERNATIVA
# Declaração / Instruções Condicionais
# Switch = uma alternativa ao IF

$nome="joão";
switch($nome){
    case 'joao': // caso
        echo "Nome é joao";
        break; //  encerra o case
    case 'ana':
        echo "Nome é ana";
        break;
    default: // mensagem padrão
    echo "Nenhum nome foi localizado";
    break;
}

# outro exemplo de switch
$qtde=10;
switch($qtde){
    case 5:
        echo "Baixo estoque";
        break;
    case 9:
        echo "teste";
        break;
        case 10:
            echo "Estoque normal.";
            break;
    default:
    echo "teste3";
    break;

}

25 - OPERADOR TERNÁRIO
# OPERADOR TERNÁRIO
# Pode substitui uma estrutura simples de if e else
# Necessita de 3 expressões ou áreas:
# 1 = a exprerssão que será avaliada como verdadeira
# 2 = a exprerssão que será executada com true
# 3 = a exprerssão que será  executada com false

$opcao = 0;
$nome = $opcao ==1?'Joao':'Antonio'; // sendo verdadeira recebe 'joao' caso contrário recebe a segunda opção.

# podemos tambem usar da seguinte forma:

$opcao ==1 ? $nome ='Joao':'Antonio';

# podemos usar o operador ternário em várias situações distintas.
# por exemplo, para apresentar um determinado texto

echo $opcao ==1?'Sim':'Não';

26 - NOVA INSTRUÇÃO CONDICIONAL MATCH
# EXPRESSÃO MATCH

# No php8 foi introduzida uma expressão condicional designada por match
# É muito semelhante ao switch, mas com uma sintaxe mais concisa

$x=10;
echo match($x){
    5=>'parou no 5',
    10,12=>'parou no 10 ou 12',
    15=>'parou no 15',
    default=>'é um número diferente de 5,10 ou 15'
}; /*redução sensivel no código*/

27 - CICLOS WHILE
# CICLOS/LOOPS
# Existem 4 tipos de ciclos em php
# Executam determinado bloco de código

# While
# Definimos a condigção durante qual o ciclo deve continuar a ser executado, sendo avaliada no inicio do ciclo.
# Quando a condição for falsa, o ciclo termina e o código avança
$x=1;
while($x <= 10){ /*enquanto for menor*/
    echo "Ciclo em Execução<br>";
    echo "<hr>";
    $x++; /*esta parte incrementa a while, caso não tenha se torna loop infinito*/
}

# Outro exemplo
$i=0;
while($i < 10){
    echo $i++ . "<br>";
}

28 - CICLO DO WHILE
# DO WHILE
# A condição é avaliada apos o execução do ciclo

$x=0;
do{
    echo $x++ ."<br>";
} while($x < 10); /*condição para continuar executando*/
echo "<br>";
echo "<br> <hr>";

$timer=100; /exemplo de contador regressivo/
do{
   echo $timer-- . "<br> E Diminuindo...";
} while ($timer >= 1);

29 - CICLO FOR
# FOR
# permite executar bloco de código determinado nuúmero de vezes
# É constituido por tres parametros
# 1.O inicializador = indica o valor inicial do contador
# 2. A Condição = indica qual a condição para que o ciclo termine
# 3. O incremento = altera o valor do condutor em cda ciclo

for ($x = 1;$x < 11;$x++){ /*para que ou enquanto*/
    echo $x ."<br>";
}
echo "<br>";

# Pode conter assinatura diferentes
$i=1;
for(;$i < 10;){ /*ignora a variavel e o incremento*/
    echo $i++ ."<br>";
}
echo "<br>";
$nomes=['Joce','Luciano','Helena'];
for ($i= 0;$i < sizeof($nomes); $i++){ /*varrando o array, sizeof = conta a qtde*/
    echo $nomes[$i]. "<br>";
}

30 - FOREACH
# FOREACH
# É um ciclo especialmente concebido para trazer uma iteração pelos valores de um array

$nomes = ['Luciano','helena','Joce','Heloisa'];
foreach($nomes as $nome){ /*a cada volta do cicloa a variavel $nomes salta de valores em valores e passa para $nome*/
    echo $nome . "<br>";
}
echo "<br>";

# existe ainda uma outra assinatura que permite ir buscar a chaves e o valor do array

$capitais=[
    'portugal'=>'Lisboa',
    'Brasil'=>'Brasilia',
    'Espanha'=>'Madrid',
    'Rússia'=>'Moscow'
];
foreach($capitais as $key => $value){ /*sendo chave e valor passando para o variavel value*/
    echo "Para o Pais $key a capital é $value<br>";
}

31 - BREAK, CONTINUE E GOTO
# BREAK CONTINUE GOTO
# existem duas funções especiais dentro dos loops: BREAK e CONTINUE

# BREAK = serve para interromper a execução de um loop

for($i = 0;$i < 20; $i++){
echo $i . "<br>";
if ($i == 10){ //caso a variavel seja igual a 10
    break; //interrompe o loop
}
}

echo "<hr>";

$nomes=['Luciano','Helena','Jocelaine','Heloisa'];
foreach($nomes as $nome){
    echo $nome ."<br>";
    if ($nome == 'Helena'){ /*quando chegar a informação*/
        break;
    }
}

# CONTINUE = permite avançar para o ciclo seguinte do código não importando o que deveria ser executado.

for($i = 0;$i < 20; $i++){
if($i == 10){
    continue; # volta a linha inicial do loop, ocorre o regresso do ciclo
}
echo $i ."<br>";
}

$nomes=['Luciano','Helena','Jocelaine','Heloisa'];
foreach($nomes as $nome){
    if ($nome == 'Helena'){ /*quando chegar a informação*/
        continue;
    }
} echo $nome ."<br>";

# GOTO
# Poquissimo usado por que torna a leitura do código mais complexa. Foi introduzido no PHP 5.3 e permite sair do loop e ir para uma linha de código definida no label (com o nome seguido de ':')
for($i = 0;$i < 20;$i++){
    if ($i == 10){
        goto teste; # salta para o label
    }
}
echo "Fim do loop";
teste: echo "AQUI";

32 - FUNÇÕES ou FUNCTIONS
# FUNCTIONS ou FUNÇÕES
# São blocos de código identificados por um  nome e uma assinatura, que permite que o código seja reutilizado e organizado de uma forma muito ais consistente.
# definimos uma função usando a palavra chave function, seguida de um nome, um conjunto de parenteses e um bloco de código.
# Forma correta de escrita de uma função.

function funcao(){
    echo "Teste com função";
}

# chamando FUNÇÃO
funcao(); // lembrando que sao case sensitive

# Não existe uma recomendação standard para determinar nome de funções, porem auxilia o snake_case (nome_nome)

33 - PARAMETROS DE FUNÇÕES
# CRIANDO OS PARAMETROS

function adicao($a,$b){ // usando parametros

}

adicionar(10,20);
adicionar(10,20);

function adicionar($a,$b){
echo "$a + $b = " .($a + $b)."<br>";
}
# no php8 já não são necessário os parenteses nas operações
echo "<hr>";

$nomes = ['Jocelaine','Helena','Heloisa','Luciano'];
foreach($nomes as $nome){
    saudacao($nome);
}


function saudacao($valor){
echo "Bom dia, $valor.<br>";
}

34 - PARAMETROS OPCIONAIS
# As chamadas destas funções não obriga a definir argumentos para esses parametros.

function multiplicar ($a,$b = 2){
# $a será o valor passado pelo argumento
#$b será:   
#   O valor do argumento se ele for passado na chamada
#   O valor2 se nao for passado, recebe sua atribuição de valor na variável, que neste caso seria '2'
echo $a * $b;
}
multiplicar(10); //O valor2 se nao for passado, recebe sua atribuição de valor na variável, que neste caso seria '2'
echo "<br>";
multiplicar(10,5); // neste caso $b vale '5'

# Os parametros opcionais devem ser definidos após os parametros não opcionais
function dividir($a=2,$b){ // desta prática não e recomendável, mas sim os parametrs vem no fim, como na primeira função cima.
echo  "<br>"."$a e $b";
}

dividir(2,10);
dividir(2); // nao ocorre a passagem para o segundo parametro, ou seja, o segundo parametro deve receber valor, mas não acontece como esta na chamada da função. Mesmo ocorre com uma mensagem de erro.

35 - NAMED ARRGUMENTS
# PARAMETROS OPCIONAIS e NAMED ARGUMENTS
# O Php8 introduz uma novidade: named arguments.
# Exemplo abaixo:

function adicionar ($a,$b=10,$c=30){
echo ($a + $b + $c)*2;
}
adicionar(100,10,300); // assim força os valores
echo "<br>";

# no php8 podemos fazer da seguinte forma:
    adicionar(c:1000,a:0); // desta forma ocorre o 'pulo' de valores, somente c e a recebem mudanças de valores, o valor final da função como resultado é afetado
    echo "<br>";
    echo "<br>";
    $raiz=10;
    $res=$raiz*$raiz;
    echo "A Raiz quadrade é: .$res";

36 - NOTAS ADICIONAIS SOBRE PARAMETROS e VARIADIC PARAMETER
# Uma função nunca deve ser chamada sem que valores obrigatórios sejam fornecidos
# exemplo:
 function funcao($a,$b){
//codigo aqui
 } 

 funcao(1,1); // forma errada, pq so foi fornecido a valor de $a
 # Contudo embora pouco frequente, podemos passar mais argumentos do que o solicitado.

 function outra_funcao($a){
    $x = func_get_arg(0); // posição dos argumentos, mesma sequencia de um array, ou seja, posição '0'
    $y = func_get_arg(1);
    $z = func_get_arg(2);
    echo "$x - $y - $z";
    echo "<br>";
    echo func_num_args(); #avalia a qtde de argumentos que foram passados
 }
 outra_funcao(10,20,30);
 echo "<br>";

 # também não muito comum, mas sendo possivel, podemos usar um argumento especial, designado por VARIADIC PARAMETER
 function minha_funcao(...$argumentos){ // as reticencias permitem percorrer os elementos e apresentar por cada volta, porem a leitura do codigo fica mais complexa
    foreach($argumentos as $v){
        echo "$v <br>";
    }
 }
 minha_funcao(10,20,30,40,50);

37 - EXPRESSÃO RETURN NUMA FUNÇÃO
# RETURN

# A declaração return provoca o fim da execução do código em uma função. Retornando ao local de onde a função foi chamada.

function falar(){
   return;
   echo "Nao vai ser apresentado texto";
}

# Opcionalmente podemos usar o returno para devolver um valor. Deste forma, uma função pode ser responsável, por exemplo, por desenvolver um conjunto de cálculos e devolver o resultado.

function adicionar($a,$b){
   $resultado = $a + $b;
   return $resultado;
   # ou

return $a + $b;
}

echo adicionar(10,20); # apresentando valor de 30

# Outro exemplo
$nome = 'Joao';
if(avaliar_nome($nome)){
   echo "<br>O Cliente esta correto.";
}

function avaliar_nome($n){
   if($n == 'Joao'){
      return true;
   }else{
      return false;
   }
}

# Uma função sem qualuer valor de retorno devolve sempre um valor nulo
function teste(){
   // código aqui
}

if(falar()===null){
   echo "Função com retorno igual a nulo"; // sera apresentado esse texto
}

38 - ESCOPO DE UMA VARIAVEL E EXPRESSÃO GLOBAL
# ESCOPO E CICLO DE VIDA DE UMA VARIÁVEL
# Normalmente uma variável de PHP passa a existir a partir do local onde é iniciada e existe até o final do seu ciclo
# No entanto, quanto temos variaveis dentro de uma função, elas tem um ciclo de vida limitado.

$varivel=10;
echo "<p>$variavel</p>";

funcao(20, 30);
//echo "<p>$a e $b</p>"; //são variaveis dentro da função

function funcao($a,$b){
 //  echo "<p>$variavel</p>";
   echo "<p>$a e $b</p>";
}

function funcao2(){
   $v = 100; // a variavel somente existe na função
}

funcao2();
echo "<p>$v</p>";

# GLOBAL
$a=10; # fora da função

function funcao3(){
global $a; // insere a variavel que estava de fora da função
$a = 20;
}

funcao3();
echo "$a"; // a variavel recebe valor 20

# GLOBALS
# Armazena os indices para serem localizados nas variaveis
$b=100;
function funcao4(){
$GLOBALS['b'] = 200; // faz a junção do indice a variavel
}

funcao4();
echo "<p>$b</p>";

# Ao contrário das funções e loops, as variaveis continuam a existir, não são destruidas

39 - FUNÇÕES ANONIMAS
# FUNÇÕES ANONIMAS
# Uma função anonima nao tem nome e pode ser definida como o valore atribuir a uma variavel.

$a = function(){
   echo "Olá.";
};

# O importante após fechar as chaves é obrigatório o ';'
$a(); // caso nao coloque ocorre erro de sintaxe

# OUTRO EXEMPLO
$falar = function($mensagem){
   echo "<p>Eu digo: $mensagem</p>";
};

$falar('Vamos de PHP na veia');

# OUTRO EXEMPLO
$andar = function($metros){
   return "Andei $metros metros."; // return devolve uma concatenção
};
echo  $andar(100);

# OUTRO EXEMPLO
$a = function(){
   return "<br>Função A";
};

function falar($x){
   echo $x;
};

falar($a()); // uma função normal chamando a função anonima

40 - CLOSURES e ARROW FUNCTION
# FUNÇÕES CLOSURE
# São funções anonimas que podem usar variaveis do escopo global
$x=20;
$y=30;

$minhaClosure = function($z) use($x,$y){ // use x e y torna-se conhecido na função
echo "$z - $x - $y";
$y +=1000; // esta instrução nao vai alterar o valor de $y
};

$minhaClosure(10);
echo "<p>$y</p>"; // o  valor de $y não foi alterado na closure

# ARROW FUNCTIONS
# São funções anonimas escritas de forma mais suscinta, suportam as mesmas carcteristicas de uma função CLOSURE. Porem capturam automaticamente as variaveis globais.

$x =20;
$y = 30;

$minhaFuncao = fn($z) => "$x - $y - $z";
echo $minhaFuncao(10); // passando o '10' para z

# fn é uma palavra reservada e nao necessita de return e nem chaves.

41 - GENERATORS
# GENERATORS
# É uma função que permite gerar séries de valores. Cada valor é devolvido pela função através da instrução YIELD. Ao contrário do return, o mesmo guarda o estado da função. Permitindo que a função continue a partir do estado de onde ficou pela última vez.

function buscar_numero(){
    for($i=0;$i < 10;$i++){
        yield $i;
    }
}

# A função geradora funcioa como um iterador, podendi ser usado num ciclo até que o gerador não tenha mais valores para devovler com o yeld.
foreach(buscar_numero() as $numero){
    echo "$numero<br>";
}

#Os geradores foram introduzidos na versão 5.5 do PHP, mas foram melhorados na versão 7 coma a introdução do yield from, que permite outro tipo de retorno:
    # dvolver valores de outro gerador
    # devolver valores em um array

    function buscar_nomes(){
        yield 'joao';
        yield 'maria';
        yield from ['carlos','ana','antonio']; // insere todo o array
        yield 'fernando';
    }

    echo "<hr>";
    foreach(buscar_nomes() as $nome){
        echo "$nome<br>";
    }

    # Como as funções geradoras nao necessitam de tratar todos os dados de uma vez, quando usadas, podem aumentar a performance no script

    # NOTA
    # O Php vem acompanhado de uma imensa coleção de funções que estao sempre disponiveis para realizar operações com arrays, com strings, comunicar com bases de dados, encriptação, operar com ficheiros e pastas, etc.

42 - INTRODUÇÃO A CLASSES, PROPRIEDADES e MÉTODOS
# CLASSES - INTRODUÇÃO A POO (OOP) - PROGRAMAÇÃO ORIENTADA A OBJETOS
# Uma classe é um molde/forma/modelo a partir do qual criamos objetos
# Exemplo: a classe humano é um modelo para, criarmos um conjunto de homens e mulheres, cada um partilhando o mesmo "molde", mas com propriedades e funções com valores diferentes.
# Homem e Mulher tem ambos cabelo, mas homem pode ter barba e cabelo escuro e a mulher cabelo claro.

# Teoricamente:
# Class Humano
    # cabelo
    # genero
    # peso
    # caminhar

# Homem -> Humano
    # cabelo - castanho
    # genero - masculino
    # peso - 75
    # caminhar()

    # CLASSES 
    # As classes são definidas pela declaração class, seu nome e bloco de comandos que contém suas propriedades e métodos.
    # por convenção PSR-1 o nome de uma classe deve ser sempre atribuido na forma de studlyCaps/PascalCase/MixedCase. O corpo deve ser definido da seguinte forma.
    class Humano{
        // propriedades
    }

    class JogadorFutebol{
        // propriedades
    }

    # O corpo de uma classe contem PROPRIEDADES e MÉTODOS
    # PROPRIEDADES - sao variaveis que guardam as caracteristicas do objeto.
    # MÉTODOS - são funções que definem o que o objeto pode fazer.

    # As propriedades, também conhecidas como fields(campos) ou atributod de uma classe.
    # No PHP as propriedades tem que ter um nivel de acesso especifico.

    class FiguraGeometrica{
        public $largura, $altura; // atributos ou fields
        public $x;
        public $y;

        function novaArea($a,$b){
            return $a * $b;
        }
    }

43 - CRIAÇÃO DE OBJETOS E INSTANCIAÇÃO
# CLASSES
# Para aceder as propriedades de uma classe, dentro dos métods da classe, é usadaa pseudo varival $this seguida do operador ->
class Humano{
    public $nome = 'joao'; 
    public $apelido =  'Ribeiro';

    public function nomeCompleto(){
        return $this -> nome . ' '. $this->apelido;
    }
}

# As classes recorrem á utilização de Acess Modifieres - Niveis de Acesso. Os niveis de acesso aos dados indicam se podemos ver os dados apenas dentro da classe.
#Se podemos ver fora da classe ou se estão protegidas por algum motivo extra.

# INSTANCIAR UM OBJETO
# Um objeto é uma variavel criada a partir de uma classe.
# Instanciar um obejto significa criar um objeto a partir de uma classe atribuindo a variavel e expressão New e o nome ca classe.

$homem=  new Humano();

# com a implementação anteriro podemos agora aceder as propriedades e métodos
echo $homem->nomeCompleto(); // joao ribeiro é o resultado retornado 

44 - INSTANCIAÇÃO
# INSTANCIAÇÃO
class Humano1{
    public $nome = 'joao';
    public $apelido = 'ribeiro';
    public function nomeCompleto(){
        return $this->nome. ' '. $this->apelido;
    }
}

$homem = new Humano1(); // instanciação
echo $homem->nomeCompleto();

# CONSTRUCTOR
# É um método especial dentro de uma classe que é sempre executado automaticamente quando é criado um objeto apartir de uma classe. Este método é definido de uma forma especial com '__' = dois underline. São chamados métodos mágicos porque tem uma execução especifica ou automatica.

class Humano{
    private $nome; # acess modifier private, valores reconhecidos somente no interior da classe
    private $apelido;

    function __construct($n,$a){ # método mágico
        $this->nome=$n;
        $this->apelido=$a;
    }

    public function nomeCompleto(){
        return $this->nome. ' '. $this->apelido; 
    }
}

$homem = new Humano('joao','ribeiro'); // instanciação
echo $homem->nomeCompleto();

45 - PROPERTY PROMOTION
# Podemos ter classes sem qualquer tipo de método e podemos ter classes sem qualquer tipo de propriedade.

$homem = new Humano1();
$homem->nome = "joao";
$homem->apelido = "ribeiro";


# No PHP8 podemos criar uma classe da seguinte forma
class Humano2{
    function __construct(public $nome, public $apelido) # construido dentro do construct
    {
        $this->nome = $nome;
        $this->apelido = $apelido;
    }
}

$h1 = new Humano1('joao','ribeiro');
$h2 = new Humano2('ana','martins');

echo $h1->nome.' '.$h1->apelido;
echo "<br>";
echo $h2->nome.' '.$h2->apelido>

# importante: A contrário do nome das variavéis, o nome das classes é case insensitive
$h3 = new humano1('nome','apelido');
echo "<br>";
echo $h3->nome.' '.$h3->apelido;

46 - CLASSES ANONIMAS
# CLASSES ANONIMAS
# Com o PHP7 foi introduzido um conceito usado noutras linguagens, conhecida como classes anonimas, para estanciar um objeto ou classe.

class Objeto1{
    function teste(){
        echo "teste - normal";
    }
}

$a = new Objeto1();

# Exemplos com classes anonimas
$b = new class{ // definição direta do objeto
    function teste(){
        echo   'teste - classe anonima';
    }
};
# NOTA: é obrigatório o ';' no final da linha da classe

$a->teste();
echo "<br>";
$b->teste();

47 - HERANÇA DE CLASSES
# HERANÇA | INHERITANCE
# A Herança é o mecanismo através do qual podemos criar clases que herdam propriedades e métodos de outra classe.
# Usamos a expressão Extends

class animal{
    public $especie;
    public $peso;

    function tipoEspecie(){
        return "Este animal é da espécie {$this->especie}";
    }
}

$animal = new Animal();
$animal->especie = 'Mamiferos';
echo $animal->tipoEspecie();

class Mamifero extends animal{
   //nao é necessário voltar a definir o que ja estava criado, apenas adicionado novos métodos ou propriedades.
   public $qtde_pernas;
   public $tem_pelo; 

   function temQtdePernas(){
    return "O Animal da espécie de {$this->especie} tem {$this->qtde_pernas}";
   }
};

$mamifero = new Mamifero();
$mamifero->especie = 'Cavalo';
$mamifero->qtde_pernas =4;
echo $mamifero->temQtdePernas();

48 - OVERRIDING
# OVERRIDING
# O Mecanismo de overriding permite a uma classe derivada, ter métodos reestritos especificamente para esse classe.
# Por exemplo podemos ter um método TESTE na classe base e ter o mesmo método TESTE com cófigo diferente na classe derivada.

class Animal{
    function mover(){
        echo "Mover a partir da classe base.";
    }
}

class Mamifero extends Animal{

}

class Peixe extends Animal{
    function mover(){
        echo "Mover a partir da classe peixe."; // redefinição da classe e seu conteudo
    }

}

$animal = new Animal();
echo $animal->mover();
echo "<br>";

$mamifero = new Mamifero();
echo $mamifero->mover();
echo "<br>";

$peixe = new Peixe();
echo $peixe->mover();

# Aplicando nas Propriedades
class Animal1{
    public $especie='Ave';
}

class Mamifero1 extends Animal1{
    public $especie = 'Cavalo';
}

$a = new Animal1();
echo $a->especie;
echo "<br>";
$b=new Mamifero1();
echo $b->especie;

# Além do conceito de classe base  e classe derivada, há o conceito de parent class(Classe pai)

class retangulo{
    public $largura,$altura;
    function __construct($l,$a)
    {
        $this->largura = $l;
        $this->altura = $a;
    }
     function calcularArea(){
        return $this->largura * $this->altura;
     }
}

class quadrado extends retangulo{
    function __construct($l){
        $this->largura = $l;
        $this->altura = $l;
    }
}
$rect = new Retangulo(10,20);
$quad= new Quadrado(10);

echo $rect->calcularArea();
echo "<br>";
echo $quad->calcularArea();
echo "<br>";

# mas podemos chamar o constutor da class base usando a expressão Parent
class quadrado1 extends retangulo{
    function __construct($l){
        parent::__construct($l,$l); // usa a classe pai ou o nome da classe base diretamente servindo como alias
    }
}

$quad = new quadrado1(5);
echo $quad->calcularArea();

49 - HERANÇA COM A EXPRESSÃO FINAL
# FINAL
# Para impedir que uma classe derivada possa fazer override de métodos podemos utilizar a expressão FINAL da seguinte forma.

class veiculo{
   final function mover(){ // nao permite alterar ou  sofre override
        // codigos
    }
}

class bicicleta extends veiculo{
    function mover(){
        // override código original
    }
}

# Podemos impedir diretamente colocando o FINAL antes de class

final class humano{ // final antes de class
    function teste(){
        echo "teste";
    }
}

class Homem extends humano{
    // código aqui
}

$a = new Homem();
$a->teste();

50 - ACCESS LEVELS PUBLIC PROTECTED PRIVATE
# ACCESS LEVELS - NIVEIS DE ACESSO

# Existem 3 tipos de niveis de acesso a elementos dentro de uma class: public, protected e private

class MinhaClass{
    public $v1;
    protected $v2;
    private $v3;
}

$a = new MinhaClass();
$a->v1 = '111'; # possivel
/*$a->v2 = '222'; # não é possivel
$a->v3 = '333'; # não é possivel*/

# PUBLIC
# Os membros pulivos de uma classe são sempre acessiveis.

class TudoPublico{
    public $propriedade;

    public function metodo(){
        echo "Método Público";
    }
}
$obj1 = new TudoPublico();
$obj1->propriedade = "a";
$obj1->metodo();

# PROTECTED

# Um elemento protected pode ser alcançado dentro da classe e dentro de uma    qualquer classe que seja uma extensão de outra classe.

class ClasseTeste{
    public $publica = "a";
    protected $protegida = "b";
    private $privada = "c";
}

class ClasseDerivada extends ClasseTeste{
    function teste(){
        echo $this->publica; # possivel
        echo $this->protegida; # possivel
        echo $this->privada; # erro
    }
}
$a = new ClasseTeste();
$a->publica = '1';# possivel
$a->protegida = '2'; # erro
$a->privada = '3'; # erro

# PRIVATE

# So pode ser visivel dentro da própria classe, não e visivel nos objetos instanciados nem noutros classes herdados.
# caso nao seja especificado o PHP entende que é public

class Teste{
    private $valor; // não existe fora da class
    function mover(){
        // codigo aqui
    }
}

$a = new teste();
$a->mover(); # possivel

51 - VAR e OBJECTS ACCESS
# VAR KEYWORD
# Tem o mesmo comportamento de public, apenas existe por retrocompatibildades devido ao código escrito antes PHP5. Não é recomendável usar porque poderá em breve ficar descontinuada.

class Homem{
    var $nome, $apelido;
}
$eu = new Homem();
$eu->nome="Joao";
$eu->apelido="Ribeiro";

# OBJECT ACCESS

# No PHP, um objeto instanciado apartir de uma classe pode aceder a elementos privados e protegidos de outro obejto criado apartir da mesma classe.

class humano{
    private $nome ="x";

    function setPrivate($objeto, $valor){
        $objeto->nome = $valor;
    }
    function apresentar(){
        echo $this->nome;
    }
}

$a = new humano();
$b = new humano();
$a->setPrivate($b,"joao"); # '->' = usar
$a->apresentar();
echo "<br>";
$b->apresentar();

52 - GETTERS e SETTER
# ACCESS LEVELS - ASPECTOS IMPORTANTES A RETER
# Uma boa prática é criar o menor número propriedades de uma classe como públicas. Coloca-la como pública é expor ela em demasia. 
# Exemplo: imaginem que querem que uma propriedade de uma classe seja sempre m número.

class humano{
    public $idade;
}
 $eu = new humano();
 $eu->idade = "Olá mundo"; # isso é possivel pq o PHP não é  strongly typed (definir o tipo de variável)

 # para definir corretamente este tipo de situação, podemos usar métodos para definir e ir buscar os valores das propriedades privadas. Estes métodos permitem garantir que a integridade das propriedades seja mantida.

 class humano1{
    private $idade;
 }

 $eu->idade="Joao"; # não é possivel por que a propriedade é privada

 # ACCESS LEVEL - ASPECTOS IMPORTANTES A RETER
 class humano2{
    private $idade = 0;

    public function setIdade($valor){   # set = define
    if(is_numeric($valor)){
        $this->idade = $valor;
    }
 } 
 

 public function getIdade(){
    return $this->idade;
 }
} 

 $eu2 = new humano2();
 $eu2->setIdade('joao');
 echo $eu2->getIdade();

53 - STATIC
# STATIC
# A palavra chave static pode ser usada para declarar propriedades e métodos de uma classe que podem ser acedidos sem que seja necessário criar um objeto a partir dessa  classe.

class teste{
    # instance members - um membro por cada objeto criado a partir da calsse
public $nome;
 function teste(){
    // codigo aqui
 }

 // static ou class members - apenas existentes uma vez na classe
 static $idade;
 static function mover(){
    // código aqui
 }
}

# STATIC - COMO FAZEM AS IMPLEMENTAÇÕES

class operacoes{
    static $valor1, $valor2;

    static function adicionar(){
        return self::$valor1 + self::$valor2; # self = eu propria, substitui o this
        // return operacoes::$valor1 + operacoes::$valor2; alternativa
    }
    static function hashAleatoria(){
        return rand(0,1000); // gera numeros aleatórios
    }
}

operacoes::$valor1 = 10;
operacoes::$valor2 = 20;
echo operacoes::adicionar();

$hash = operacoes::hashAleatoria();
echo "<br

54 - EXEMPLO PRÁTICO DE STATIC
class operacoes{
    // retorna um numero sorteado entre $min e $max
    static function numeroAleatorio($min,$max){
        return rand($min,$max);
    }
    static function calcularFormula($a,$b){
        // (A * 2) + (B * A)
        return($a*2)+($b*$a);
    }
    static function criarNome(){
        $nomes = ['Joce','Luciano','Helena','Heloisa'];
        $apelidos = [' Grassi',' Leal',' Constante',' Rodrigues'];
        return $nomes[rand(0,count($nomes)-1)].''.$apelidos[rand(0,count($apelidos)-1)];
    }
}

echo operacoes::numeroAleatorio(0,1000);
echo "<br>";
echo operacoes::calcularFormula(10,20);
echo "<br>";
echo operacoes::criarNome();

55 - CONSTANTS, CONST e DEFINE
# CONSTANTS
# São variaves cujo valor atribuido na sua definição não pode ser aletrado ao longo do script de PHP.
# O PHP permite definir constantes de duas formas: com o termo const e como método define

# CONST
# Const é usado para definir constantes no contexto da classes. Ao conrário das propriedades public, protected ou private, as propriedades const estão sempre visiveis (são publicas). Como não podem ser alteradas no valor, nao existe o risco de ficarem expostas.

# Para definir uma constante, o nome deve ser sempre em maisculas, podendo ser usados '_'. Não é necessário o sinal do dollar como nas variaveis normais.

class circulo{
    const PI = 3.14; // todas as constantes tem que ter o valor atribuido sempre que são definidas
}

// é possivel apresentar sem instanciar
echo circulo::PI;
echo "<br>";

// ou  com instanciação
$c = new circulo();
echo $c::PI;

# AINDA SOBRE CONSTANTS
# O termo const nao deve ser aplicado a variavies locais ou parametros. Desede o PHP 5.3 o termo const pode ser usado para criar constantes globais.

const APP_NAME = 'Minha Aplicação';
echo "<br>";
echo APP_NAME;
echo "<br>";

# dentro de uma função
function teste(){
    echo APP_NAME;
}

teste();
# não é possivel concatenar constantes da mesma forma que fazemos com variaveis.
echo "<br>Nome.: ".APP_NAME; // concatenação da forma correta

# DEFINE
# A função define permite definir constantes globais e locais, mas não permite ser usada dentro do contexto de uma classe
define('APP_NAME1','Minha Aplicação'); // nome da constante(string) e após a tipo
define('VERSÃO','1.0.0');
define('MOSTRAR ERRO',true);
define('PI',3.14);

echo "<br>";
echo APP_NAME1 .' '.VERSÃO;
echo "<br>";

# Por nome devemos definir os nomes das constantes sempre com maiuscula. Em versões anteriores da linguagem era possivel usar um terceiro parametro para indicar que a constante era case insensitive. Desde o PHP 7.3 esta opção já não é mais válida.

/*define('CONSTANTE',100,true); // o terceiro parametro esta desatualizado
echo CONSTANTE ."<br>";
//echo constante ."<br>"; // erro pois a nova versão é case sensitive*/

# CONSTANTS

# Para veficarmos se uma constante já existe
if(!defined('APP_NAME3')){ // se nao esta definida 
    define('APP_NAME3','Minha App'); // entao defina para
}else{
    echo "Constante já existe.";
}

echo APP_NAME3;
echo "<br>";

# ou mais comum ainda...
defined('CONSTANTE') or define('CONSTANTE','valor'); // faz a verificação e caso nao exista, é criada após o 'or'

# Com o PHP 5.6 passou a ser possivel definir uma constante com um array
const NOMES = ['Luciano','Leal','Rodrigues'];
echo NOMES[0].' '.NOMES[1].' '.NOMES[2];
echo "<br>";

# Com o PHP 7, passou a ser possivel usar arrays no define
define('NAMES',['Luciano','Torcedor','Gremista']);
echo NAMES[1];

56 - CONSTANTES MÁGICAS
# CONSTANES MÁGICAS

# As constantes mágicas são 8 e são designadas assim porque o seu valor varia automaticamente dependendo onde estão a ser usados
# Vamos perceber como funciona.
echo __LINE__. "<br>"; # indica o numero da linha de código no script
echo __FILE__. "<br>"; # identifica o caminho completo do script
echo __DIR__. "<br>"; # identifica a pasta onde o script está alocado

teste();
function teste(){
    $a = true;
    echo __FUNCTION__. "<br>"; # indica o nome da função
}

class MinhaClasse{
    function identificar(){
        echo __CLASS__. "<br>"; # indica o nome da classe
        echo __METHOD__. "<br>"; # indica o nome do método
    }
}

$a = new MinhaClasse();
$a->identificar();
# __TRAIT__ está relacionado com um mecanismo de reutilização de código

echo __NAMESPACE__ ; # indica o nome do namespace atual

57 - CLASSES ABSTRATAS
# CLASSES ABSTRATAS

# É constituida por uma implementação parcial a partir das quais outras classes podem crescer.

# Quando uma classe é declarada como abstrata, isso significa que ela tem métodos incompletos que, obrigatoriamente tem que ser implementados nas classes que a herdam

# Não podem ser instanciadas. Servem apenas para serem herdadas por outras classes

abstract class Forma{
    public $largura=100, $altura=200;

    abstract public function area();

    function altura(){
        return $this->altura;
    }
}

// quadrado = new Forma(); # isto não é permitido

class Retangulo extends Forma{
    public function area()
    {
        return $this->altura * $this->altura;
    }
}

$r = new Retangulo();
echo $r->area();
echo "<br>";
echo $r->altura();

# Uma classe abstrata permite então uma implementação parcial de métodos e a definição de uma modelo de implementação de outros métodos. Isto permite em modelos de programação orientada a objetos, juntamente com outro mecanismo, designado por interfaces, a estruturação do código que segue os melhores padrões da escrita 

58 - TRAITS E SUA UTILIDADES
# TRAITS

# São um grupo de métodos que podem ser inseridos dentro de uma classe e foram adicionados à linguagem na sua versão 5.4 para aumentar a reutilização de código.

# Os Traits são definidos com a expressão trait, seguido pelo nome e por um bloco de código. As regras para dar nomes a traits são as mesmas que usamos nas classes.

trait MinhasHabilidades{
    public function falar($mensagem){
        echo "Eu digo: $mensagem";
    }

    public function saltar($metros){
        echo "Eu salto: $metros de distancia";
    }
}

# As classes que necessitarem de usar estes métodos do triat, apenas terão que ter o seguint:

class Humano{ // a classe humano herda os metodos do trait
    use MinhasHabilidades;
}

$h = new Humano();
$h->falar("Olá mundo!");
echo "<br>";
$h->saltar(3);

59 - INTRODUÇÃO DO INCLUDE
# IMPORTAR SCRIPTS COM INCLUDE

# A grande maioria dos projetos de programação vão sempre necessitar de ter o seu código "partido" entre diferentes ficheiros. Salvo raras exceções, um projeto terá dexenas ou centenas de ficheiros para que a aplicação funcione.

# É aqui que entram os mecanismos de importação de scripts dentro de outros scripts. A importação pode ser feita recorrenso ao uso da instrução include.

# NOTA: o include, é semelhante ao echo, são construções especiais do PHP e nao requerem a utilização de parenteses.

include '2.php';

# Esta instrução vai inserir o código de programação so scripts config.php do script atual.

echo NOME_APLICACAO; // esta informação vem do 2.php

# CAMINHO PARA INCLUDE
# Podemos incluir um script dentro de outro usando:
# 1 - nenhm caminho e apenas o nome do script a ser incluido
# 2 - um caminho relativo ao script atual
# 3 - um caminho absoluto - que indica a localização exata do script do filesystem

# 1 - apenas quando o script incluir na mesma pasta do script atual.
# 2 - caminho relativo á pasta do script atual
include 'inc/dados.php';
echo "<br>";
echo $nome;

# Quando fomos retornar entre pastas usamos ../
include '../inc/dados.php';
echo "<br>";
echo $nome;

# 3 - CAMINHO ABSOLUTO OU LOCALIZAÇÃO EXATA
include 'C:\laragon\www\index.php'; // botao direito em cima do arquivo copiar caminho, em serivores linux a 'barra deve ser invertido' /
echo "<br>";
echo $nome;

60 - UTILIZAÇÃO DO REQUIRE E DIFERENÇA RELATIVA DO INCLUDE
# Além do include, existem tres formas de importação de scripts
/*
require
include_once
require_once

O Require é muito semelhante ao include. As mesma regas de definição dos caminhos são aplicadas. A diferença entre o include e o require é que, no caso de iclude falhar, o código avança com um aviso. No caso do require falhar, a aplicação termina com um erro.
*/

include 'teste.php'; // mostra a mensagem de erro e continua a execução
echo "momento 1"; 

require 'teste.php'; // mostra um aviso(warning) e depois o erro e não exexcuta o restante do script
echo "momento 2";

# QUAL USAR ENTRE OS 2 TIPOS
# É aconselhável o uso do REQUIRE, uma vez que, acontecendo um erro de importação do script, a aplicação não irá avançar com erros.

61 - REQUIRE ONCE e INCLUDE ONCE
# INCLUDE ONDE e REQUIRE ONCE

# A expressão include_once funciona como o include, no entanto se o script já foi anteriormente incluido, o PHP não volta a incluir.

include_once '2.php';
echo NOME_APLICACAO;
echo "<br>";

include_once '2.php'; # esta linha nao vai carregar o mesmo script
echo 'BBB';
echo "<br>";

/*
No caso do require_once, funciona exatamente como o require, mas com o mesmo comportamento do include_once. Se o ficheiro já foi incorporado anteriormene não voltará a ser incorporado
*/

require_once '2.php';
echo 'CCC';
echo "<br>";

require_once '2.php';
echo 'DDD';

62 - DECLARATION TYPE
# DECLARATION  TYPE
/*
Quando dissemos que o PHP não é uma linguagem tipificada, isto é, as variaveis não tem necessariamente que ser definidas com um tipo, não é bem assim
É possivel especificar claramente que tipo de valor podemos usar para parametros de funções, propriedades de classes e tipos de retorno de funções.
Vejamos no caso de um array como parametro de uma função.
*/

function falar(array $mensagem){
    echo $mensagem;
}

//falar('joao'); // não é possivel

function converter(string $mensagem){
    echo $mensagem;
}

# TYPE DECLARATIONS
/*
As declarações de tipo foram acrescentadas no PHP 5.1. Outros tipos apenas foram adicionados na versão PHP 7 o tipo mixed.
O Tipo callable tem que ser uma função,método ou objeto. Podemos, por exemplo, usar uma função anonima
*/
$falar = function($mensagem){
    echo "A Minha mensagem é:".$mensagem;
    
    function minha_funcao(callable $funcao,$dados){
$funcao($dados);
    }

    minha_funcao($falar, "esta é  a minha mensagem.");
};

# Tipos bool, int, float s string foram adicionados na versão 7. É contudo necessário ter em conta que o php faz conversões automáticas de tipos.

function funcao(): array{
    return[
        1,2,3
    ];
} // tera erro, pq dentro da função a mesma espera que receba uma string

function funcao2():string{
    return['Luciano'];
}

63 - STRICT TYPING
# STRICT TYPING
declare(strict_types=1); // verdadeiro como tipos declarados e nao podem ser mudados, esta declaração deve sempre estar em cima da estrutura.
# O comportamento do PHP é tentar converter os tipos declarados.

function falar(string $mensagem){
    echo $mensagem;
}

falar('Olá mundo'); // é possivel
falar(2500); // é possivel pq foi convertido

function somar(int $v1, int $v2){
    return $v1 + $v2;
}

echo somar(10,20); // é possivel
echo somar('a','b'); // é possivel

# Mas podemos 'obrigar' o PHP a seguir a regra estritamente definida



function falar1(?string $mensagem){ // '?' força o PHP aceitar tipo automáticos
    echo $mensagem;
}

falar1('Minha mensagem');
falar1(null); // também é possivel 

# Com o PHP 8 aparece a possibilidae de definirmos mais do que um tipo para o mesmo argumento. Os tipos podem ser apenas separados por barras verticais

function conversar(int|string $mensagem){
    echo $mensagem;
}

conversar('olá mundo');
conversar(2500);

# Ou caso dois tipos de retorno
function calcular_quadrado_de(int|float $v1): int|float{ // segunda parte após ':' e o que sera devolvido
    return $v1 * $v1;
    return 'joao';
} 

echo calcular_quadrado_de(25);
echo calcular_quadrado_de('joao');

# sao mecanismos que auxiliam em menos erros quando for criar

64 - TYPE CONVERSION
# TYPE CONVERSION

#   Embora o PHP automaticamente faz uma conversão de dados entre diferentes tipos, é uma boa prática explicitar isso no código. Uma variavel do  tipo int não é o mesmo que uma string e vice-versa.

$meu_boleano = true;
echo $meu_boleano; // resulta numa string vazia
echo (int)$meu_boleano;

# Designamos esta operação como conversão explicita (explicit cast), podemos fazer converter os principais tipos de valores.
# (string), (int),(float),(array);

# vejamos o caso da conversão de um array num objeto
$nomes= ['Joce','Luciano','Helena','Heloisa'];

$nomes1 = (object)$nomes;
echo "<pre>";
print_r($nomes);

# podemos converter uma variavel num array com unico valor
$nome1 = 'joao';
$os_nomes = (array)$nome1;
print_r($os_nomes);

65 - TESTANDO VARIAVES COM ISSET, EMPTY e UNSET
# TESTANDO VARIÉVEIS

# Acontece inúmeras vezes no nosso código a necessidade de verificar ou testar a existencia ou do seu valor

# Para isso o PHH contém um conjunto de construções intenas que nos permitem fazer essa verificação.

# ISSET

# Esta construção permite verificar se uma variável esta ou não definida, ela retorna verdadeiro ou  falso.

$a = 1;
if (isset($a)){
    echo "A Variável existe. <br>";
}else{
    echo "Não esta definida.";
}

# Se tiver variavel definida e o valor for nulo (null), é considerada uma variavel inexsitente.

$b=null;
echo isset($b)?"Sim":"Não";

# EMPTY

# Verifica se a varável possui valor vazio(null,0,false ou string vazia) e retorna verdadeiro ou falso.

$b = 'Joao <br>';
empty($c);

$c = false;
empty($c);

$nome=[];
empty($nome);

$outro=null;
empty($outro);

# Com o PHP8 houve uma mudança na forma como o is_null funciona. Anteriormente  ao testar com o is_null uma variavel inexistente era apresentado resultado verdadeiro como um aviso. Com o PHP8 passa a existir um erro de tipo.


# UNSET

# Permite 'destruir' uma variável. Existem duas formas de o fazer, com liheiras diferenças de performance e atuação no sistema.

$a = 'joao';
unset($a);

$b='Antonio';
$b=null;

# No primeiro caso a variavel é 'liberada' e no próximo ciclo de limpeza (garbage collector) ela é removida da memória.
# No segundo caso a variável vai persistir na memória mas sem valor atribuido apesar da libertar memória quanto a inexistencia de valor.
# sugere a utilização do unset.

66 - NULL COALESCING OPERATOR
# NULL COALESCING OPERATOR
# Com o PHP7 foi introduzido o Operador de Coalescência de Nulos, que significa aglutinação ou junção de itens saperados.

# basicamente este operador é um atalho para alguns casosdo operador condicional ternário.

$x=null;
$nome= $x ?? 'Sem nome'; // '??' pergunta se o x é nulo

$nome=isset($x) ? $x : 'Sem nome';

# Portanto se x for nulo será atribuido o valor definido a fte dos dois sinais de interrogação

$apelido = null;

$apelido ??='Apelido desconhecido.';
echo $nome;
echo '<br>';
echo $apelido;

67 - VERIFICAR TIPO DE VARIÁVEL
# VERIFICAR O TIPO DA VARIÁVEL

# O PHP contém um conjunto de vastas funções que permitem avaliar que tipo de dados estão guardados dentro de uma variável.
$nome = 'Meu nome';
$idade=47;
$acordado=true;

if(is_array($nome)){
    echo "É um array"; // verificando com o is_ + tipo
}else{
    echo "Não é um array.";
}

if(is_bool($acordado)){
    echo "<br>É um valor booleano";
}

if(is_int($idade)){
    echo "<br>Confirmado: valor inteiro";
}

# OUTRAS FUNÇÕES SIMILARES
/*
is_callable() se é função anonima
is_float ou is_double()
is_real
is_int() ou is_integer()
is_long()
is_null()
is_numeric()
is_object()
is_string()
*/

68 - APRESENTAÇÃO DE INFORMAÇÕES DE VARIÁVEIS
# APRESENTAÇÃO DE INFORMAÇOES DE VARIÁVEIS

# O PHP tem 3 funções fundamentais para obter informações a partir de variavies do nosso codigo.
/*
print_r
var_dump
var_export
*/

# PRINT_R
/*
Permite ver dados de uma varável de uma forma simples de ler e frequentemente usada para efeitos de debug.
*/
echo "<pre>"; // facilita ainda mais a leitura
$a = 'joao';
print_r($a);
echo "<br>";
$b=[1,2,3];
print_r($b); // mostra array e posições de valores

# VAR_DUMP
/*
Tem como resultado selemelhante ao print_r, mas para além dos valores apresenta tambem a informação sobre o itpo de valores.
*/

$nome='João';
var_dump($nome); // mostra o tipo e a qtde na informação, especifica mais 
echo "<br>";
$valores = [1,2.4,3];
var_dump($valores);

# VAR_EXPORT
/*
Apresenta informação sobre uma variável num estilo que pode ser usado como código PHP.
*/

$nome='Joao';
var_export($nome);

echo "<br>";
$valores=[1,2,3];

var_export($valores);
echo "<br>";

$numeros = [];

for($i = 0; $i < 10;$i++){
    $numeros[]=rand(0,100);
}

var_export($numeros); // após o resultado copiamos os valores do browser e inserimos em uma variável.
$nova = array (
    0 => 62,
    1 => 49,
    2 => 31,
    3 => 92,
    4 => 52,
    5 => 85,
    6 => 5,
    7 => 41,
    8 => 66,
    9 => 19,
);

echo print_r($nova);

69 -  O PRÓXIMO PASSO
/*
ao longo desta playlist estivemos a ver muito aspectos sobre a sintaxe desta linguagem.

daqui para frente ocorre avanços na liguagem apartir do segundo módulo.
*/
















































